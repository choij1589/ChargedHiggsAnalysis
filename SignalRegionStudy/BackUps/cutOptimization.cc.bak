#include <iostream>
#include <cmath>
using namespace std;

double getMetricWithSlope(TH2D *hSigProj, TH2D *hBkgProj, double xprime, double yprime);
double getMetricWithCuts(TH2D *hSigProj, TH2D *hBkgProj, double xcut, double ycut);
void printOptimization(TString signal, const double mA, const double sigma, const double width);

void cutOptimization() {
    vector<TString> SIGNALs = {"MHc-70_MA-15",
                               "MHc-70_MA-40",
                               "MHc-70_MA-65",
                               "MHc-100_MA-15",
                               "MHc-100_MA-60",
                               "MHc-100_MA-95",
                               "MHc-130_MA-15",
                               "MHc-130_MA-55",
                               "MHc-130_MA-90",
                               "MHc-130_MA-125",
                               "MHc-160_MA-15",
                               "MHc-160_MA-85",
                               "MHc-160_MA-120",
                               "MHc-160_MA-155"};
    vector<double> MAs = {15., 40., 64.9,
                          15., 59.9, 94.9,
                          15., 54.9, 89.9, 125.,
                          15., 84.9, 120., 155.};
    vector<double> SIGMAs = {0.11033, 0.182434, 0.471047,
                             0.0930342, 0.344411, 0.604872,
                             0.117027, 0.243583, 0.718199, 0.879492,
                             0.120021, 0.578887, 1.00985, 1.48121};
    vector<double> WIDTHs = {0.134634, 0.685245, 0.979598,
                             0.171075, 0.965929, 1.75398,
                             0.111275, 1.02639, 1.18526, 2.37517,
                             0.119447, 1.39002, 1.84166, 2.56311};

    for (unsigned int i = 0; i < SIGNALs.size(); i++) {
        auto signal = SIGNALs.at(i);
        auto mA = MAs.at(i);
        auto sigma = SIGMAs.at(i);
        auto width = WIDTHs.at(i);
        cout << "@@@@ Start optimizing for " << signal << "..." << endl;
        printOptimization(signal, mA, sigma, width);
    }

}

void printOptimization(TString signal, const double mA, const double sigma, const double width) {
    const double window = sqrt(pow(sigma, 2) + pow(width, 2));

    vector<TString> conversion = {"DYJets", "ZGToLLG"};
    vector<TString> diboson = {"WZTo3LNu_amcatnlo","ZZTo4L_powheg"};
    vector<TString> ttX = {"ttWToLNu", "ttZToLLNuNu", "ttHToNonbb"};
    vector<TString> rare = {"WWW", "WWZ", "WZZ", "ZZZ", "TTG", "tZq", "VBF_HToZZTo4L", "GluGluHToZZTo4L"};
    vector<TString> MCSamples;
    for (const auto &s: conversion) MCSamples.emplace_back(s);
    for (const auto &s: diboson)    MCSamples.emplace_back(s);
    for (const auto &s: ttX)        MCSamples.emplace_back(s);
    for (const auto &s: rare)       MCSamples.emplace_back(s);

    // get histograms
    TString histkey = "SR3Mu/Central/" + signal + "/3D";
    TString promptDir = "../data/PromptEstimator/2018/Skim3Mu__GraphNet__WeightVar__";
    TFile *f = nullptr;
    // signal
    f = new TFile(promptDir+"/PromptEstimator_TTToHcToWAToMuMu_"+signal+".root", "read");
    TH3D *hSig = (TH3D*)f->Get(histkey); hSig->SetDirectory(0);
    f->Close();

    TH3D *h = nullptr;
    // fake
    f = new TFile("../data/NonpromptEstimator/2018/Skim3Mu__GraphNet__/DATA/NonpromptEstimator_SkimTree_SS2lOR3l_DoubleMuon.root", "read");
    h = (TH3D*)f->Get(histkey);
    TH3D *hBkg = (TH3D*)h->Clone("hBkg"); hBkg->SetDirectory(0);
    f->Close();

    // conv
    f = new TFile(promptDir+"/PromptEstimator_SkimTree_SS2lOR3l_DYJets.root", "read");
    h = (TH3D*)f->Get(histkey); h->Scale(0.628); h->SetDirectory(0);
    hBkg->Add(h);
    f->Close();

    // diboson
    for (const auto &sample: diboson) {
        f = new TFile(promptDir+"/PromptEstimator_SkimTree_SS2lOR3l_"+sample+".root", "read");
        h = (TH3D*)f->Get(histkey);
        hBkg->Add(h);
        f->Close();
    }

    // ttX
    for (const auto &sample: ttX) {
        f = new TFile(promptDir+"/PromptEstimator_SkimTree_SS2lOR3l_"+sample+".root", "read");
        h = (TH3D*)f->Get(histkey);
        hBkg->Add(h);
        f->Close();
    }

    for (const auto &sample: rare) {
        f = new TFile(promptDir+"/PromptEstimator_SkimTree_SS2lOR3l_"+sample+".root", "read");
        h = (TH3D*)f->Get(histkey);
        hBkg->Add(h);
        f->Close();
    }
    
    // restrict 3D histograms to mass window
    const int xL = hSig->GetXaxis()->FindBin(mA-window);
    const int xR = hSig->GetXaxis()->FindBin(mA+window);
    hSig->GetXaxis()->SetRange(xL, xR);
    hBkg->GetXaxis()->SetRange(xL, xR);

    auto *hSigProj = (TH2D*)hSig->Project3D("yz");
    auto *hBkgProj = (TH2D*)hBkg->Project3D("yz");

    // optimize with grid search
    double bestXprime = 1., bestYprime = 1., bestMetric = 0.;
    cout << getMetricWithSlope(hSigProj, hBkgProj, 0., 0.) << "\t";
    for (float i = 0; i <= 4; i+= 0.01) {
        for (float j = 0; j <= 4; j += 0.01) { 
            double metric = getMetricWithSlope(hSigProj, hBkgProj, i, j);
            if (bestMetric < metric) {
                bestXprime = i;
                bestYprime = j;
                bestMetric = metric;
            }
        }
    }
    cout << bestXprime << "\t" << bestYprime << "\t" << bestMetric << "\t";
    double bestXcut = 0., bestYcut = 0.; bestMetric = 0.;
    for (float i = 0; i <= 1; i+= 0.01) {
        for (float j = 0; j <= 1; j += 0.01) {
            double metric = getMetricWithCuts(hSigProj, hBkgProj, i, j);
            if (bestMetric < metric) {
                bestXcut = i;
                bestYcut = j;
                bestMetric = metric;
            }
        }
    }
    cout << bestXcut << "\t" << bestYcut << "\t" << bestMetric << endl;
}

double getMetricWithSlope(TH2D *hSigProj, TH2D *hBkgProj, double xprime, double yprime) {
    double nSig = 0., nBkg = 0;

    if (xprime == 0 && yprime == 0) {
        nSig = hSigProj->Integral();
        nBkg = hBkgProj->Integral();
    }
    else {
        for (unsigned int i = 0; i <= hSigProj->GetNbinsX(); i++) {
            for (unsigned int j = 0; j <= hSigProj->GetNbinsY(); j++) {
                const double scoreX = hSigProj->GetXaxis()->GetBinCenter(i);
                const double scoreY = hSigProj->GetYaxis()->GetBinCenter(j);

                if (! ((scoreX / xprime) + (scoreY / yprime) > 1.)) continue;
                const unsigned int thisBin = hSigProj->FindBin(scoreX, scoreY);
                nSig += hSigProj->GetBinContent(thisBin);
                nBkg += hBkgProj->GetBinContent(thisBin);
            }
        }
    }
    if (nBkg == 0) return 0.;

    return sqrt(2*((nSig+nBkg)*log(1+nSig/nBkg)-nSig));
}

double getMetricWithCuts(TH2D *hSigProj, TH2D *hBkgProj, double xcut, double ycut) {
    double nSig = 0, nBkg = 0;

    for (unsigned int i = 0; i <= hSigProj->GetNbinsX(); i++) {
        for (unsigned int j = 0; j <= hSigProj->GetNbinsY(); j++) {
            const double scoreX = hSigProj->GetXaxis()->GetBinCenter(i);
            const double scoreY = hSigProj->GetYaxis()->GetBinCenter(j);

            if (scoreX < xcut) continue;
            if (scoreY < ycut) continue;
            const unsigned int thisBin = hSigProj->FindBin(scoreX, scoreY);
            nSig += hSigProj->GetBinContent(thisBin);
            nBkg += hBkgProj->GetBinContent(thisBin);
        }
    }
    if (nBkg == 0) return 0.;

    return sqrt(2*((nSig+nBkg)*log(1+nSig/nBkg)-nSig));
}
